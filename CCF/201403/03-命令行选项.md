* 每个命令行由若干个字符串组成,它们之间恰好由一个空格分隔。
* 这些字符串中的第一个为该命令行工具的名字,由小写字母组成,你的程序不用对它进行处理。
* 在工具名字之后可能会包含若干选项,然后可能会包含一些不是选项的参数。
* 选项有两类:带参数的选项和不带参数的选项。
  * 一个合法的无参数选项的形式是一个减号后面跟单个小写字母,如"-a" 或"-b"。
  * 而带参数选项则由两个由空格分隔的字符串构成,
    * 前者的格式要求与无参数选项相同,
    * 后者则是该选项的参数,是由小写字母,数字和减号组成的非空字符串。
* 如果该小写字母后面紧跟了一个冒号,它就表示一个带参数的选项,否则则为不带参数的选项

* 对于每个命令行,你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项,又不是某个合法选项的参数时,分析就停止。
* 命令行剩余的未分析部分不构成该命令的选项,因此你的程序应当忽略它们。
* 每个字符串里只包含小写字母,数字和减号。

### 输入格式：
* 输入的第一行是一个格式字符串,
  * 它至少包含一个字符,且长度不超过 52。
  * 格式字符串只包含小写字母和冒号
  * 保证每个小写字母至多出现一次,不会有两个相邻的冒号,也不会以冒号开头。
* 输入的第二行是一个正整数 N(1 ≤ N ≤ 20),表示你需要处理的命令行的个数。
* 接下来有 N 行,每行是一个待处理的命令行,它包括不超过 256 个字符。
  * 该命令行一定是若干个由单个空格分隔的字符串构成,每个字符串里只包含小写字母,数字和减号。
### 输出格式：
* 输出有 N 行。
* 其中第 i 行以"Case i:" 开始,然后应当有恰好一个空格,
* 然后应当按照字母升序输出该命令行中用到的所有选项的名称
* 对于带参数的选项,在输出它的名称之后还要输出它的参数
* 如果一个选项在命令行中出现了多次,只输出一次。
* 如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。


strtok函数学习：
strtok函数用于分割字符串，原型如下：
```
char *strtok(char *str, const char *delim);
```
str为指向欲分割的字符串，delim为分隔符，实例如下：
```cpp
#include <stdio.h>
#include <string.h>
 
int main(void)
{
        char s[] = "aaa bbb ccc ddd";
        char c[] = " ";
 
        char *r = strtok(s, c);
 
        while (r != NULL) {
                printf("%s\n", r);
                r = strtok(NULL, c);
        }
 
        return 0;
}
```

[标准答案](https://blog.csdn.net/tigerisland45/article/details/54974448)
* 读入包含空行的字符串，
* strtok函数使用
* 更新命令行

### 关于回答：

题解中：
```cpp
// 选项未出现过则添加
   if(m.find(sv[j]) == m.end())
       m[sv[j]] = "";

   // 更新参数：后出现优先
   if(format[pos+1] == ':' && j+1 < (int)sv.size()) {
       m[sv[j]] = sv[j+1];
       j++;
   }

```

问题代码：
```
if(format[pos+1] == ':' && j+1 < (int)sv.size()) {
       m[sv[j]] = sv[j+1];
       j++;
   }
   else{
   m[sv[j]]="";
   }

```

#### 解释：
给一个样例：
* 正解输出：
```cpp
albw:x
1
ls -a -w 12 -w
Case 1: -a -w 12
```
* 问题代码输出：
```cpp
albw:x
1
ls -a -w 12 -w
Case 1: -a -w
```

##### 分析：

* 问题代码：默认无参数相当于有参数的一种（参数为：无），
* 但是题意是： 如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。







