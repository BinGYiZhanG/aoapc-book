
#### 排序数组无法记录点的变化

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <string>
#include <algorithm>

using namespace std;


const int inf=0x3f3f3f3f;
int n;///据点数n，编号1~n
int m;///m条双向道路
int k;///计算出每个据点最近地k个行星发动机据点

///接下来n个整数表示据点类型
///1：行星发动机据点；0：普通据点

///接下来m行，u，v，w表示有一条长度为w的双向道路

int e[10010][10010],d[10010];
int type[10010];///记录据点的类型
bool vis[10010];///

struct node{
    int dis,type;
};

bool cmp(const node& a,const node& b){///按照是否为行星据点，距离小大排序
    if(a.type==b.type&&a.type==1)
        return a.dis>b.dis;
    else
        return a.type>b.type;
}

///基本思路：Dijskstra更新从结点到每个点的最短距离，然后排序,依次相加,
void Dijsktra(int s){
    fill(d,d+10010,inf);
    memset(vis,0,sizeof(vis));

    d[s]=0;

    for(int i=0;i<n;i++){
        int minn=inf,u=-1;
        for(int j=1;j<=n;j++){
            if(minn>d[j]&&vis[j]==false){
                minn=d[j];
                u=j;
            }
        }

        if(u==-1)
            break;

        vis[u]=true;
        for(int v=1;v<=n;v++)
            if(vis[v]==false&&e[u][v]!=inf)
                if(d[v]>d[u]+e[u][v])
                    d[v]=d[u]+e[u][v];


    }
}


int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
        scanf("%d",type+i);

    fill(e[0],e[0]+10010*10010,inf);
    memset(type,0,sizeof(type));

    int u,v,w;
    for(int i=0;i<6;i++){
        scanf("%d%d%d",&u,&v,&w);
        e[u][v]=e[v][u]=w;
    }

    for(int i=1;i<=n;i++){
        node nd[n+1];
        Dijsktra(i);
        for(int j=1;j<=n;j++){
            nd[j].dis=d[j];
            nd[j].type=type[j];
        }
        sort(nd+1,nd+n+1,cmp);

        for(int j=1;j<=n;j++){
            printf("第%d个点的距离:%d,type:%d\n",j,nd[j].dis,nd[j].type);
        }

        cout<<endl;

        /*
        int sdis=0;
        int cntk=0;
        if(type[i]==1)///如果该点也是据点，则加1
            cntk++;

        for(int j=2;j<=n;j++){///第一个点是本身，不用加了
            if(nd[j].type==1&&nd[j].dis!=inf){///可达
                cntk++;
                sdis+=nd[j].dis;
                if(cntk==k)
                    break;
            }
        }

        if(cntk<k){///说明据点不够，得加上所有
            sdis=0;
            for(int j=2;j<=n;j++){
                if(nd[j].dis!=inf){
                    sdis+=nd[j].dis;
                }
            }
        }

        printf("%d\n",sdis);
*/
    }

    return 0;
}
```
