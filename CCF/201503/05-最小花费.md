### 问题描述
* C国共有n个城市。有n-1条双向道路，每条道路连接两个城市，任意两个城市之间能互相到达。小R来到C国旅行，他共规划了m条旅行的路线，第i条旅行路线的起点是si，终点是ti。在旅行过程中，小R每行走一单位长度的路需要吃一单位的食物。C国的食物只能在各个城市中买到，而且不同城市的食物价格可能不同。
* 然而，小R不希望在旅行中为了购买较低价的粮食而绕远路，因此他总会选择最近的路走。现在，请你计算小R规划的每条旅行路线的最小花费是多少。
### 输入格式
* 第一行包含2个整数n和m。
* 第二行包含n个整数。第i个整数wi表示城市i的食物价格。
* 接下来n-1行，每行包括3个整数u, v, e，表示城市u和城市v之间有一条长为e的双向道路。
* 接下来m行，每行包含2个整数si和ti，分别表示一条旅行路线的起点和终点。
### 输出格式
* 输出m行，分别代表每一条旅行方案的最小花费。
### 样例输入
```
6 4
1 7 3 2 5 6
1 2 4
1 3 5
2 4 1
3 5 2
3 6 1
2 5
4 6
6 4
5 6
```
### 样例输出
```
35
16
26
13
```
### 样例说明
* 对于第一条路线，小R会经过2->1->3->5。其中在城市2处以7的价格购买4单位粮食，到城市1时全部吃完，并用1的价格购买7单位粮食，然后到达终点。
### 评测用例规模与约定
* 前10%的评测用例满足：n, m ≤ 20, wi ≤ 20；
* 前30%的评测用例满足：n, m ≤ 200；
* 另有40%的评测用例满足：一个城市至多与其它两个城市相连。
* 所有评测用例都满足：$1 ≤ n, m ≤ 105，1 ≤ wi ≤ 106，1 ≤ e ≤ 10000$。


#### ```Dijsktra算法```不可以!!!

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>


using namespace std;

const int maxn=10010;
const int inf=0x3f3f3f3f;
int e[maxn][maxn];
int weight[maxn],d[maxn],w[maxn];
bool vis[maxn];
int n,m;

void Dijskstra(int s) {
    fill(d, d + maxn, inf);
    fill(w,w+maxn,inf);
    fill(vis,vis+maxn,false);
    d[s] = 0;//不能加vis[s]=true,否则报错
    w[s]=0;
    for (int i = 0; i < n; i++) {
        int u = -1, MIN = inf;
        for (int j = 0; j < n; j++) {
            if (vis[j] == false && d[j] < MIN) {
                u = j;
                MIN = d[j];
            }
        }
        //找不到小于INF的d[u],则剩下的顶点和集合S不连通
        if (u == -1)
            return;
        vis[u] = true;
        for (int v = 0; v < n; v++) {
            if (vis[v] == false && e[u][v] != inf ){
                if(d[u] + e[u][v] < d[v]) {
                    d[v] = d[u] + e[u][v];
                    w[v]=w[u]+weight[v];
                }
                else if(d[u]+e[u][v]==d[v]){
                    if(w[v]>w[u]+weight[v]){
                        w[v]=w[u]+weight[v];
                    }
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&weight[i]);
    int u,v,z;
    for(int i=1;i<n;i++){
        scanf("%d %d %d",&u,&v,&z);
        e[u][v]=e[v][u]=z;
    }

    for(int i=0;i<m;i++){
        scanf("%d %d",&u,&v);

        Dijskstra(u);
        printf("%d\n",w[v]);
    }

    return 0;
}


```

[题解](https://blog.csdn.net/tigerisland45/article/details/55259651)
#### 得用```DFS```写，

```






```






