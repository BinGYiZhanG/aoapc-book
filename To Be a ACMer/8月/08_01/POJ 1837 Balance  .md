Gigel有一个奇怪的“天平”并且他想要平衡它。实际上，这个设备和其他普通的天平不同。<br>
它有两个重量微不足道的手臂并且每根手臂长度是15。<br>
一些钩子附着在那些手臂上，并且Gigel想要挂一些他收藏的重量为G（1 \leq G \leq 20）的物品来直到那些唯一的价值<br>
最后，Gigel设法平衡设备通过使用他在NIO比赛中获得的经验。现在他想要知道有多少种方式能够使天平平衡。<br>

了解挂钩的重新划分和权重设置后，编写一个程序来计算平衡设备的可能性。<br>
保证对于一个测试用例至少有一个解。<br>

### 输入：
* 第一行，C（2<=C <=20），G（2<=G<=20）
* C个整数（每个数是唯一的并且按照递增排序）在[-15,15]范围内，表示钩子的划分。每个数字代表在X轴上相对于天平中心的距离（当没有附加砝码时，装置保持平衡并与X轴对齐;距离的绝对值表示钩子与平衡中心之间的距离，数字的符号决定了钩子所附的平衡臂:“-”表示左臂，“+”表示右臂）<br>
* 接下来是G个自然数，唯一的并且按照递增排序，在[1,25]范围内，代表重量的价值。

### 输出：
输出平衡天平的M种可能.

### ```dp[i][j]```数组:在挂满前i个钩码时，平衡度为j的挂法的数量。
### 初始状态：$dp[0][7500]=0$
### 状态转移方程：$dp[i][j+w[i]*c[k]]=\sum (dp[i-1][j])$
### 怎么就平衡了？

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

int dp[21][15000];
int W[21];///G个重物的重量
int D[21];///C个钩子距离天平中央的距离
int main(){
    int C,G;
    scanf("%d%d",&C,&G);
    for(int i=1;i<=C;i++)
        cin>>D[i];

    for(int i=1;i<=G;i++)
        cin>>W[i];
    memset(dp,0,sizeof(dp));
    dp[0][7500]=1;

    for(int i=1;i<=G;i++){
        for(int j=0;j<=15000;j++){
            if(dp[i-1][j])
                for(int k=1;k<=C;k++)
                    dp[i][j+W[i]*D[k]]+=dp[i-1][j];
        }
    }

    cout<<dp[G][7500]<<endl;
    return 0;
}

```
