## 迷宫问题 
### 1,DFS方法：POJ 1979 Red and Black（红与黑）
### 2,BFS方法:
#### 坑：不能用cnt记录步数，因为如果用cnt，相当于把所有的路径全搜一遍，记录的就不是起点到终点的路径了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<queue>
using namespace std;

char mp[22][22];
int mov[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
bool vis[22][22];
int d[22][22];
int n,m;
int cnt;
struct node{
    int x,y;
}st,ed;

bool islegal(int x,int y){
    if(x<0||x>=n||y<0||y>=m||mp[x][y]=='#'||mp[x][y]=='@'||vis[x][y]==true)
        return false;
    return true;
}

void DFS(node pos){
    cnt++;
    vis[pos.x][pos.y]=true;
    for(int i=0;i<4;i++){
        node tmp;
        tmp.x=pos.x+mov[i][0];
        tmp.y=pos.y+mov[i][1];
        if(!islegal(tmp.x,tmp.y))    continue;
        DFS(tmp);
    }
    return ;
}

void BFS(){
    queue<node> q;
    q.push(st);
    d[st.x][st.y]=0;
    while(!q.empty()){
        node top=q.front();
        q.pop();
        vis[top.x][top.y]=true;
        //cnt++;
        if(top.x==ed.x&&top.y==ed.y)    break;
        for(int i=0;i<4;i++){
            node tmp;
            tmp.x=top.x+mov[i][0];
            tmp.y=top.y+mov[i][1];
            if(!islegal(tmp.x,tmp.y))   continue;
            //vis[top.x][top.y]=true;
            q.push(tmp);
            d[tmp.x][tmp.y]=d[top.x][top.y]+1;
        }
    }
}

int main(){
    while(scanf("%d%d",&m,&n)==2&&m&&n){
        getchar();
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                scanf("%c",&mp[i][j]);
                if(mp[i][j]=='S'){
                    st.x=i;
                    st.y=j;
                }
                if(mp[i][j]=='G'){
                    ed.x=i;
                    ed.y=j;
                }
            }
            getchar();
        }
        cnt=0;
        fill(vis[0],vis[0]+22*22,false);
        BFS();
        printf("%d\n",d[ed.x][ed.y]);
    }
    return 0;
}

```

### 3,A*算法（迭代加深搜索）
《算法竞赛入门经典》书上看过，还背了代码，可惜不从基础入手，难以自己熟练应用.
```cpp

```


### 4,带有转向的迷宫问题
该问题在《算法入门经典》也见过，忘了是哪题了，反正代码背得很欢乐，咱还是不会用。。。













