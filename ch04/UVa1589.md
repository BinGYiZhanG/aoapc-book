```cpp
#include <iostream>
#include <cmath>

using namespace std;

char map[11][10];

//改变黑棋子将军的位置
void change_pos_black(int t, int& x, int& y)
{
    if (t == 3)
    {
        x--;
    } else if (t == 2)
    {
        x++;
    } else if (t == 1)
    {
        y--;
    } else if (t == 0)
    {
        y++;
    }
}

//判断是否越界
bool yuejie_black(int x, int y)
{
    if (x < 1 || x > 3 || y < 4 || y > 6)
    {
        return true;
    }
    return false;
}

//判断两个旗子之间是否有棋子
bool exist_chest(char axis, int pos1, int pos2, int common_axis)
{
    if (axis == 'x')
    {
        for (int i = pos1 + 1; i < pos2; i++)
        {
            if (map[common_axis][i] != '0')
            {
                return true;
            }
        }
        return false;
    } else if (axis == 'y')
    {
        for (int i = pos1 + 1; i < pos2; i++)
        {
            if (map[i][common_axis] != '0')
            {
                return true;
            }
        }
        return false;
    }
}

//车杀死将军函数
bool kill_J_ju(int ju_x, int ju_y, int J_x, int J_y)
{
    int kill_J = 0;
    if (ju_x == J_x)///在同一行
    {
        if (ju_y == J_y)
        {
            kill_J = 0; //黑将吃掉红棋子
        } else if (ju_y < J_y)
        {
            if (!exist_chest('x', ju_y, J_y, J_x))///判断该行上是否有棋子
            {
                kill_J = 1;
            }
        } else if (ju_y > J_y)
        {
            if (!exist_chest('x', J_y, ju_y, J_x))
            {
                kill_J = 1;
            }
        }
    } else if (ju_y == J_y)///列相同
    {
        if (ju_x == J_x)
        {
            kill_J = 0;
        } else if (ju_x < J_x)
        {
            if (!exist_chest('y', ju_x, J_x, J_y))
            {
                kill_J = 1;
            }
        } else if (ju_x > J_x)
        {
            if (!exist_chest('y', J_x, ju_x, J_y))///就不对应
            {
                kill_J = 1;
            }
        }
    }
    if (kill_J == 1)
    {
        return true;
    } else
    {
        return false;
    }
}
///感觉x与y不对应,以上函数

//帅杀死将军函数
bool kill_J_G(int G_x, int G_y, int J_x, int J_y)
{
    int kill_J = 0;
    if (G_y == J_y)///在同一列
    {
        if (!exist_chest('y', J_x, G_x, J_y))///就对应
        {
            kill_J = 1;
        }
    }
    if (kill_J == 1)
    {
        return true;
    } else
    {
        return false;
    }
}

//统计两个棋子之间的其他棋子个数
int count_other_chest(char axis, int pos1, int pos2, int common_chest)
{
    int count_chest = 0;
    if (axis == 'x')
    {
        for (int i = pos1 + 1; i < pos2; i++)
        {
            if (map[common_chest][i] != '0')
            {
                count_chest++;
            }
        }
    } else if (axis == 'y')
    {
        for (int i = pos1 + 1; i < pos2; i++)
        {
            if (map[i][common_chest] != '0')
            {
                count_chest++;
            }
        }
    }
    return count_chest;
}

//炮杀死将军
bool kill_J_pao(int J_x, int J_y, int pao_x, int pao_y)
{
    int kill_J = 0;
    int count_not_zero = 0;
    if (J_x == pao_x)  ///行相等时
    {
        if (J_y == pao_y)///列也相同
        {
            kill_J = 0;
        } else if (pao_y < J_y)
        {
            if (count_other_chest('x', pao_y, J_y, pao_x) == 1)///正常
            {
                kill_J = 1;
            }
        } else if (pao_y > J_y)
        {
            if (count_other_chest('x', J_y, pao_y, pao_x) == 1)
            {
                kill_J = 1;
            }
        }
    } else if (J_y == pao_y) ///列相等时
    {
        if (J_x == pao_x)
        {
            kill_J = 0;
        } else if (pao_x < J_x)
        {
            if (count_other_chest('y', pao_x, J_x, pao_y) == 1)
            {
                kill_J = 1;
            }
        } else if (pao_x > J_x)
        {
            if (count_other_chest('y', J_x, pao_x, pao_y) == 1)
            {
                kill_J = 1;
            }
        }
    } else  //行列都不想等时
    {
        kill_J = 0;
    }

    if (kill_J == 1)
    {
        return true;
    } else
    {
        return false;
    }
}

//马杀死黑将
bool kill_J_M(int M_x, int M_y, int J_x, int J_y)
{
    int kill_J = 0;
    if ((abs(M_x - J_x) == 2 && abs(M_y - J_y) == 1))///'日'字形
    {
        if (M_x < J_x)
        {
            if (map[M_x + 1][M_y] == '0')///不蹩马腿
            {
                kill_J = 1;
            }
        } else if (M_x > J_x)
        {
            if (map[M_x - 1][M_y] == '0')///不蹩马腿
            {
                kill_J = 1;
            }
        }
    } else if ((abs(M_x - J_x) == 1 && abs(M_y - J_y) == 2))///‘双口’形
    {
        if (M_y < J_y)
        {
            if (map[M_x][M_y + 1] == '0')
            {
                kill_J = 1;
            }
        } else if (M_y > J_y)
        {
            if (map[M_x][M_y - 1] == '0')
            {
                kill_J = 1;
            }
        }
    }
    if (kill_J == 1)
    {
        return true;
    } else
    {
        return false;
    }
}

int main()
{
    int n_red, pos_black_x, pos_black_y;
    int pos_red_x[7], pos_red_y[7];
    while ((cin >> n_red >> pos_black_x >> pos_black_y) && n_red)
    {
        for (int i = 1; i <= 10; i++)
        {
            for (int j = 1; j <= 9; j++)
            {
                map[i][j] = '0';
            }
        }
        map[pos_black_x][pos_black_y] = 'J';

        for (int i = 0; i < n_red; i++)
        {
            char qizi;
            cin >> qizi >> pos_red_x[i] >> pos_red_y[i];
            map[pos_red_x[i]][pos_red_y[i]] = qizi;
        }

        //输出数据
//      for (int i = 1; i <= 10; i++)
//      {
//          for (int j = 1; j <= 9; j++)
//          {
//              cout << map[i][j] << " ";
//          }
//          cout << endl;
//      }

        //判断开局的局面是否是红棋输
        int begin = 0;
        for (int i = 0; i < n_red; i++)
        {
            if (map[pos_red_x[i]][pos_red_y[i]] == 'G')
            {
                if (pos_red_y[i] == pos_black_y)///在同一列上
                {
                    for (int line = pos_red_x[i] - 1; line > pos_black_x;
                            line--)///判断该列上有没有棋子
                    {
                        if (map[line][pos_black_y] != '0')
                        {
                            begin = 1;
                        }
                    }
                } else
                {
                    begin = 1;
                }
            }
        }
        if (begin == 0)
        {
            cout << "NO" << endl;
            continue;
        }

        ///模仿将军走一步,记得更新黑将的状态,上一步的状态删除,上上步的状态删除
        int t = 4;
        int step_by_J = 0;
        char be_killed = '0';
        while (t--)
        {
//          cout << "**********" << endl;
            int temp_x = pos_black_x, temp_y = pos_black_y;
            change_pos_black(t, temp_x, temp_y);///四个方向
            if (!yuejie_black(temp_x, temp_y))///判断  将  是否越界
            {
                step_by_J++;
                for (int i = 0; i < n_red; i++)
                {
                    if (temp_x == pos_red_x[i] && temp_y == pos_red_y[i])///如果红棋将军
                    {
                        be_killed = map[pos_red_x[i]][pos_red_y[i]];
                        pos_red_x[i] = 0;///更新位置
                        pos_red_y[i] = 0;
                        break;
                    }
                }
                map[pos_black_x][pos_black_y] = '0';///
                map[temp_x][temp_y] = 'J';///更新位置
            } else if (yuejie_black(temp_x, temp_y))
            {
//              cout << "将军这一步越界了" << endl;
//              cout << "**********" << endl;
                continue;
            }
            //四个将军函数如下
            for (int i = 0; i < n_red; i++)
            {
                if (map[pos_red_x[i]][pos_red_y[i]] == 'R')  ///车杀死将军
                {
                    int pos_C_x = pos_red_x[i];
                    int pos_C_y = pos_red_y[i];
//                  cout << "车 杀死将军的结果: "
//                          << kill_J_ju(pos_C_x, pos_C_y, temp_x, temp_y)
//                          << endl;
                    if (kill_J_ju(pos_C_x, pos_C_y, temp_x, temp_y) == 1)
                    {
                        step_by_J--;
                        break;
                    }
                } else if (map[pos_red_x[i]][pos_red_y[i]] == 'G')  //帅杀死黑将
                {
                    int pos_G_x = pos_red_x[i];
                    int pos_G_y = pos_red_y[i];
//                  cout << "帅 杀死将军的结果: "
//                          << kill_J_G(pos_G_x, pos_G_y, temp_x, temp_y)
//                          << endl;
                    if (kill_J_G(pos_G_x, pos_G_y, temp_x, temp_y) == 1)
                    {
                        step_by_J--;
                        break;
                    }
                } else if (map[pos_red_x[i]][pos_red_y[i]] == 'C')
                {
                    int pos_P_x = pos_red_x[i];
                    int pos_P_y = pos_red_y[i];
//                  cout << "炮 杀死将军的结果: "
//                          << kill_J_pao(temp_x, temp_y, pos_P_x, pos_P_y)
//                          << endl;
                    if (kill_J_pao(temp_x, temp_y, pos_P_x, pos_P_y) == 1)
                    {
                        step_by_J--;
                        break;
                    }
                } else if (map[pos_red_x[i]][pos_red_y[i]] == 'H')
                {
                    int pos_M_x = pos_red_x[i];
                    int pos_M_y = pos_red_y[i];
//                  cout << "马 杀死将军的结果: "
//                          << kill_J_M(pos_M_x, pos_M_y, temp_x, temp_y)
//                          << endl;
                    if (kill_J_M(pos_M_x, pos_M_y, temp_x, temp_y) == 1)
                    {
                        step_by_J--;
                        break;
                    }
                }
            }
            if (!yuejie_black(temp_x, temp_y))
            {
                map[temp_x][temp_y] = be_killed;
            }
//          cout << "**********" << endl;
        }
//      cout << "生存的次数: " << step_by_J << endl;
//      if (step_by_J > 0 && t == 0)
//      {
//          cout << "NO";
//      } else if (step_by_J < 0 && t == 0)
//      {
//          cout<<"YES";
//      }
//      else
        if (step_by_J > 0)
        {
            cout << "NO" << endl;
        } else
        {
            cout << "YES" << endl;
        }

    }
    return 0;
}
```
