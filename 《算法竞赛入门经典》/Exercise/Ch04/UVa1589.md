
### 1，变量定义
#### 定义结构体，x,y存储坐标，t存储棋子类型
#### tab0模拟棋盘，tab模拟暂时存在的棋盘
#### c[]存储红棋的位置+类型，c[0]记录 将 的下一个位置
#### movh记录马可以行进的坐标，mov记录将可以行进的坐标
#### 在蹩马腿时，利用了mov和movh的对应关系
```cpp
struct chess{
    char t;
    int x,y;
};

int n;
chess c[8];
chess gnr;
char tab0[11][11],tab[11][11];

int mov[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
int movh[8][2]={ {-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1},{-2,1} };

```

### 2，
#### (1),判断棋子是否合法
```cpp
bool legal(int x,int y){
    return 1<=x&&x<=3&&4<=y&&y<=6;///写成&了
}
```
#### (2),计算 将 与 红棋 之间的棋子个数
```cpp

int cnt(chess p1,chess p2){
    int cnt=0;
    if(p1.x==p2.x){
        int add=p1.y>p2.y?-1:1;
        for(int i=p1.y+add;i!=p2.y;i+=add){
            if(tab[p1.x][i]!='0')   cnt++;
        }
    }
    else if(p1.y==p2.y){
        int add=p1.x>p2.x?-1:1;
        for(int i=p1.x+add;i!=p2.x;i+=add){
            if(tab[i][p1.y]!='0')   cnt++;
        }
    }
    else
        cnt=-1;
    return cnt;
}
```
### 3，判断 能否将死
```cpp
///c[0]:存  将移动的位置  之后的位置
bool check(){
    for(int i=1;i<=n;i++){
        if(c[i].x==c[0].x && c[i].y==c[0].y)    continue;
        if(c[i].t='R'||c[i].t=='G') {
            if(cnt(c[i],c[0])==0)
                return false;
        }
        if(c[i].t=='C'){
            if(cnt(c[i],c[0])==1)
                return false;
        }
        if(c[i].t=='H'){
            for(int j=0;j<8;j++){
                if(c[i].x+movh[j][0]==c[0].x && c[i].y+movh[j][1]==c[0].y
                   &&tab[c[i].x+mov[j/2][0]][c[i].y+mov[j/2][1]]=='0')
                    return false;
            }
        }
    }
    return true;
}
```
### 4,主函数
```cpp

int main(){
    while(cin>>n>>gnr.x>>gnr.y&&(n||gnr.x||gnr.y)){
        memset(tab0,'0',sizeof(tab0));
        tab0[gnr.x][gnr.y]='1';
        for(int i=1;i<=n;i++){
            cin>>c[i].t>>c[i].x>>c[i].y;
            tab0[c[i].x][c[i].y]=c[i].t;
        }

        bool res=true;
        for(int i=0;i<4;i++){
            memcpy(tab,tab0,sizeof(tab0));
            c[0].x=gnr.x+mov[i][0];
            c[0].y=gnr.y+mov[i][1];
            if(!legal(c[0].x,c[0].y))   continue;
            tab[c[0].x][c[0].y]='1';
            tab[gnr.x][gnr.y]='0';
            if(check()){
                res=false;
                break;
            }
        }
        if(res) puts("YES");
        else    puts("NO");
    }
    return 0;
}

```
