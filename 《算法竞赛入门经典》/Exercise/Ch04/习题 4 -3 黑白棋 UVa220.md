8 X 8 棋盘 ,
《奥赛罗》是一款由两个人在一块8×8的棋盘上玩的游戏，棋盘的一面是白色的，另一面是黑色的。一个玩家放置白色一面朝上的棋子，另一个玩家放置黑色一面朝上的棋子。玩家轮流将一个棋子放在棋盘上一个空闲的位置上。在放置棋子时，棋子必须将至少一个其他颜色棋子括起来。如果棋子位于水平、垂直或对角线上的直线上，则在每条直线的两端都有当前棋子颜色的棋子，则将棋子括起来。当进行移动时，括号内的所有棋子将更改为进行移动的棋子的颜色。(棋子有可能在一次移动中跨越多个行。)

### 输入
输入一个8 X 8的棋盘乙级当前下一次操作的游戏者，处理三种指令：
* L：打印所有合法操作，按照从上到下，从左到右，
* Mrc：
输入完毕后，输出黑白方棋子总数
* Q： 退出游戏，并打印当前棋盘

* ‘-’ indicating an unoccupied square
* ‘B’ indicating a square occupied by a black disk
* ‘W’ indicating a square occupied by a white disk
第9行是‘B’或者‘W’表明目前棋手是哪一方，你或许可以假定数据是合法地标准形式。<br>
然后有一系列命令，命令将会对目前棋手放置所有可能的移动，或者放弃比赛。然后每行一个命令在输入里。
### 输出：

命令和相应的输出以下面格式给出：

#### 列出目前棋手的所有可能移动。

在一行的第一列是命令“L”。程序应该度过棋盘，以（x,y）的形式打印当前棋手所有的可能移动，
* 按行优先顺序打印
* 如果一行有多个列，按升序打印
所有合法的移动应该在一行打印，如果没有任何移动对于当前棋手来说括起任何棋子的不可能的，那么就打印“No legal move.”


#### 做出一个移动
在一行的第一列是命令“M”，在第2,3列跟着两个数字，。除非当前玩家没有合法的移动，否则数字是放置当前玩家颜色块的行和列。如果当前玩家没有合法的移动，则首先将当前玩家更改为其他玩家，并且该移动将是新当前玩家的移动。你或许应该假定移动是合法的，你应该在板上记录改变，包括添加新棋子和改变所括起来棋子的颜色。在最后的移动上，打印“Black - xx White - yy”，xx代表黑棋的数量；yy代表白棋的数量。在一个移动之后，目前起皱应该转换为不再移动的棋手。

#### 放弃目前的游戏
在一行的第一列是命令“Q”，在这个点，打印最后的棋盘配置使用与输入相同的形式。这个终止当前游戏的输入。

您可以假设这些命令在语法上是正确的。在不同游戏的输出之间放一行空白，在输出的任何地方都不要放空白行。


## 再模拟几遍就出来了
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#pragma warning (disable: 4996)
using namespace std;

char qipan[10][10];
char cmdgrp,cmd;//操作方
int mov[][2] = { {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1} };
/*mov排序：
812
7A3
654

棋盘是1~8
*/

bool legal(int x, int y) {
	if (x <= 0 || x > 8 || y <= 0 || y > 8 || qipan[x][y] == cmdgrp)
		return false;
	//如果越界，或者相邻的棋子还是同方的，返回false
	return true;
}

void printCmd() {
	for (int i = 1; i <= 8; i++) {
		for (int j = 1; j <= 8; j++) {
			if (qipan[i][j] == cmdgrp) {
				for (int k = 0; k < 8; k++) {
					int posx = i + mov[k][0];
					int posy = j + mov[k][1];
					if (legal(posx, posy) == false) continue;
					//可以判断一段连续棋子是否被夹住了

					//看连续棋子走向
					//1,横着,即，mov[k][0]==0,
					if (mov[k][0] == 0) {
						do { 
							posx += mov[k][0]; 
							posy += mov[k][1];
						} while (legal(posx,posy)==true&&qipan[posx][posy]!='-');
					//直到越界,或者该位置已经放置同方棋子了，或者该位置没放棋子
						if (legal(posx,posy)==false)
							break;//如果放置同方棋子了,或者越界，则跳出，因为该操作已不合法
						if (qipan[posx - mov[k][0]][posy - mov[k][1]] == cmdgrp)
							break;//防止出现样例1，(4,3)情况，即两个同方棋子并排放
						printf("(%d,%d)", posx, posy);
					}



				}
			}
		}
	}
}

void printQipan() {

}

int main() {
	int T;
	scanf("%d", &T);
	while (T--) {

		for (int i = 1; i <= 8; i++) {
			scanf("%s",qipan[i]);
		}
		/*
		for (int i = 1; i <= 8; i++) {
			printf("%s\n", qipan[i]);
			
		}
		*/
		getchar();//吸收回车
		scanf("%c", &cmdgrp);
		//printf("%c\n", cmdgrp);
		while (scanf("%c", &cmd) == 1 ) {
			if (cmd == 'Q') {
				printQipan();
				break;
			}
			if (cmd == 'L') {
				printCmd();
				printf("\n");
			}
		}
		
	}
}



```














